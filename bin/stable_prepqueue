#!/usr/bin/perl -w -I /home/latest/repos/slaby-scripts/perl
use strict;
use Error qw(:try);
use Git;
use StableHelper;

die "invalid arguments" if (scalar @ARGV < 2);

my $sdir = shift @ARGV;
my $srepo = Git->repository($sdir);
my $repo = Git->repository();
my $newer = qr/3\.(1[3-9]|[2-9][0-9])|[4-9]\.|[1-9][0-9]\./;
my $first_git = "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2";
my $myver = '3.12';

print "Parsing full history up to v$myver\n";

my %full_history;
my $full_history_file = "/tmp/full-hist-$myver";
if (-f "$full_history_file") {
	print "\t... from cache $full_history_file\n";
	open(HIST, "<$full_history_file") or die "cannot open $full_history_file for r";
	%full_history = map {
		chomp;
		$_ => 1
	} <HIST>;
	close HIST;
} else {
	open(HIST, ">$full_history_file") or die "cannot open $full_history_file for w";
	%full_history = map {
		chomp;
		print HIST "$_\n";
		$_ => 1
	} $srepo->command('rev-list', "$first_git..v$myver");
	close HIST;
}

print "Parsing history v$myver..stable-$myver\n";

my @history = $srepo->command('log', '--format=%B', "v$myver..stable-$myver");
@history = StableHelper::get_upstream_commits(@history);
my %history;
@history{@history} = undef;

my %further;
my %maybe_remove;
my %localSHAs;
my @removed;

sub remove($$) {
	my ($msg, $file) = @_;
	print $msg, " ", scalar $repo->command('rm', $file);
	push @removed, $file;
}

print "Parsing ", scalar @ARGV, " patches\n";

foreach my $patch (@ARGV) {
	print "  Handling $patch\n";
	open(FILE, "<", $patch) || die "cannot open $patch";
	my @header = ();
	while (my $line = <FILE>) {
		chomp $line;
		last if $line eq "---";
		push @header, $line;
	}
	close FILE;

	# remove duplicates
	my @SHAs = StableHelper::get_upstream_commits(@header);
	if (scalar @SHAs == 1 && exists $history{$SHAs[0]}) {
		remove("DUP", $patch);
		next;
	}

	# remove patches for later stables only
	if (scalar @SHAs == 1) {
		my @stabletags;
		git_cmd_try {
			@stabletags = grep(/^cc:.*stable@.*[\s#]v?$newer/i,
				$srepo->command('show', '--format=%B', '-q',
					$SHAs[0]));
		} "SHA $SHAs[0] does not exist for $patch";
		if (scalar @stabletags == 1 && $stabletags[0] !~ /$myver/) {
			remove("LATER", $patch);
			next;
		}
	}

	# lines with "Fixes: ..."
	my @fixes = map { /fixes.*\s([0-9a-f]{8,})/i ? ($1) : ()  } @header;
	if (scalar @fixes) {
		my $remove = 1;
		foreach my $fix (@fixes) {
			$fix = $srepo->command_oneline('rev-parse', $fix);
			if (exists $history{$fix}) {
				print "\tFixes stable history\n";
				$remove = 0;
				last;
			}
			if (defined $full_history{$fix}) {
				print "\tFixes full history\n";
				$remove = 0;
				last;
			}
		}
		if ($remove) {
			$maybe_remove{$patch} = [ @fixes ];
		}
	}

	$further{$patch} = 1;
	foreach my $sha (@SHAs) {
		$localSHAs{$sha} = $patch;
	}
}

print "Removing\n";

whole:
foreach my $patch (keys %maybe_remove) {
	my $fixes = $maybe_remove{$patch};
	foreach my $fix (@$fixes) {
		if (exists $localSHAs{$fix}) {
			print "not removing $patch as it fixes local $localSHAs{$fix}\n";
			next whole;
		}
	}

	remove("FIX", $patch);
	delete $further{$patch};
}

if (scalar keys %further) {
	system('sed', '-i', 's#Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>#Signed-off-by: Jiri Slaby <jslaby@suse.cz>#',
		keys %further) == 0 or die "cannot exec sed";
}

my $rmregexp = join '|', @removed;

print "Updating series\n";

open(FILE, "<", "series") || die "cannot open series for r";
my @series = <FILE>;
close FILE;

@series = grep(!/^$rmregexp$/, @series);
if (scalar @series) {
	open(FILE, ">", 'series') || die "cannot open series for w";
	print FILE @series;
	close FILE;
} else {
	$repo->command_noisy('rm', 'series');
}

1;
